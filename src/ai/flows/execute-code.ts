'use server';

/**
 * @fileOverview This file defines a Genkit flow for executing code and generating output.
 *
 * - executeCode - A function that takes code and language, and returns the simulated output.
 * - ExecuteCodeInput - The input type for the executeCode function.
 * - ExecuteCodeOutput - The return type for the executeCode function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const ExecuteCodeInputSchema = z.object({
  code: z.string().describe('The code block to be executed.'),
  language: z.string().describe('The programming language of the code (e.g., C++, React Native, Python).'),
  previousTranscript: z.string().optional().describe('The existing transcript of the execution session, including any prior user input.'),
  userInput: z.string().optional().describe("The new line of input from the user to the program."),
});
export type ExecuteCodeInput = z.infer<typeof ExecuteCodeInputSchema>;

const ExecuteCodeOutputSchema = z.object({
  output: z.string().describe("The program's output to stdout."),
  isWaitingForInput: z.boolean().describe('Set to true if the program has paused and is waiting for the user to provide stdin.'),
});
export type ExecuteCodeOutput = z.infer<typeof ExecuteCodeOutputSchema>;

export async function executeCode(
  input: ExecuteCodeInput
): Promise<ExecuteCodeOutput> {
  return executeCodeFlow(input);
}

const prompt = ai.definePrompt({
  name: 'executeCodePrompt',
  input: {schema: ExecuteCodeInputSchema},
  output: {schema: ExecuteCodeOutputSchema},
  prompt: `You are a very careful code execution simulator. Your response MUST be in JSON format matching the provided schema.

Your task is to simulate the execution of the provided code and return the exact output.

{{#if previousTranscript}}
The program is already running and is waiting for input. The user has just provided a new line of input.
Continue the simulation from where it left off.

- **Output:** Your response should only contain the *new* output generated by the program after processing the user's input. Do NOT repeat the previous transcript.
- **Waiting for Input:** Determine if the program is now waiting for another line of input and set \`isWaitingForInput\` accordingly.

**Code:**
\`\`\`{{{language}}}
{{{code}}}
\`\`\`

**Previous Transcript (including latest user input):**
\`\`\`
{{{previousTranscript}}}
\`\`\`

{{else}}
This is the *initial* run of the program.

**Code to Execute:**
\`\`\`{{{language}}}
{{{code}}}
\`\`\`

- **Output:** Simulate the program's execution from the beginning until it either finishes or prompts for user input. The \`output\` field must contain everything the program would print to standard output (\`stdout\`) during this segment of execution.
  - **Example 1 (Simple Print):** If the code is \`print("hello")\`, the \`output\` field in your JSON response must be exactly \`"hello\\n"\`.
  - **Example 2 (Waiting for Input):** If the code is \`name = input("Enter name: ")\`, the \`output\` field must be \`"Enter name: "\` and you MUST set \`isWaitingForInput\` to \`true\`.
- **Waiting for Input:**
  - If the program runs to completion without asking for input, set \`isWaitingForInput\` to \`false\`.
  - If the program stops to wait for user input, set \`isWaitingForInput\` to \`true\`.
{{/if}}`,
});

const executeCodeFlow = ai.defineFlow(
  {
    name: 'executeCodeFlow',
    inputSchema: ExecuteCodeInputSchema,
    outputSchema: ExecuteCodeOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);

'use server';

/**
 * @fileOverview This file defines a Genkit flow for executing code and generating output.
 *
 * - executeCode - A function that takes code and language, and returns the simulated output.
 * - ExecuteCodeInput - The input type for the executeCode function.
 * - ExecuteCodeOutput - The return type for the executeCode function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const ExecuteCodeInputSchema = z.object({
  code: z.string().describe('The code block to be executed.'),
  language: z.string().describe('The programming language of the code (e.g., C++, React Native, Python).'),
  previousTranscript: z.string().optional().describe('The existing transcript of the execution session, including any prior user input.'),
  userInput: z.string().optional().describe("The new line of input from the user to the program."),
});
export type ExecuteCodeInput = z.infer<typeof ExecuteCodeInputSchema>;

const ExecuteCodeOutputSchema = z.object({
  output: z.string().describe("The program's output to stdout. This must include any newlines."),
  isWaitingForInput: z.boolean().describe('Set to true if the program has paused and is waiting for the user to provide stdin.'),
});
export type ExecuteCodeOutput = z.infer<typeof ExecuteCodeOutputSchema>;

export async function executeCode(
  input: ExecuteCodeInput
): Promise<ExecuteCodeOutput> {
  return executeCodeFlow(input);
}

const prompt = ai.definePrompt({
  name: 'executeCodePrompt',
  input: {schema: ExecuteCodeInputSchema},
  output: {schema: ExecuteCodeOutputSchema},
  prompt: `You are a machine. Your sole function is to simulate code execution. You MUST respond in JSON format matching the provided schema. Do not add any explanation.

{{#if previousTranscript}}
A program is already running. The user has just provided a new line of input. Continue the simulation from where it left off.

- **Current Code:**
\`\`\`{{{language}}}
{{{code}}}
\`\`\`
- **Execution Transcript (including latest user input):**
\`\`\`
{{{previousTranscript}}}
\`\`\`
- **Task:**
  1.  Simulate the program's next step using the user's input.
  2.  Your JSON \`output\` field MUST contain only the *new* output generated by this step. Do NOT repeat any part of the previous transcript.
  3.  Set \`isWaitingForInput\` to \`true\` if the program is now waiting for more input, otherwise set it to \`false\`.

{{else}}
This is the initial execution of the program.

- **Code to Execute:**
\`\`\`{{{language}}}
{{{code}}}
\`\`\`
- **Task:**
  1. Simulate the program's execution from the beginning until it either finishes or prompts for user input.
  2. Your JSON \`output\` field MUST contain everything the program prints to standard output (\`stdout\`).
  3. **CRITICAL:** If the code is \`print("hello")\`, the \`output\` field in your JSON response must be exactly \`"hello\\n"\`.
  4. **CRITICAL:** If the code is \`name = input("Enter name: ")\`, the \`output\` field must be \`"Enter name: "\` and \`isWaitingForInput\` MUST be \`true\`.
  5. Set \`isWaitingForInput\` based on whether the program has paused for user input.

{{/if}}`,
});

const executeCodeFlow = ai.defineFlow(
  {
    name: 'executeCodeFlow',
    inputSchema: ExecuteCodeInputSchema,
    outputSchema: ExecuteCodeOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
